\hypertarget{textpage_8cpp}{\section{core/textpage.cpp File Reference}
\label{textpage_8cpp}\index{core/textpage.\+cpp@{core/textpage.\+cpp}}
}
{\ttfamily \#include \char`\"{}textpage.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}textpage\+\_\+p.\+h\char`\"{}}\\*
{\ttfamily \#include $<$kdebug.\+h$>$}\\*
{\ttfamily \#include \char`\"{}area.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}debug\+\_\+p.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}misc.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}page.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}page\+\_\+p.\+h\char`\"{}}\\*
{\ttfamily \#include $<$cstring$>$}\\*
{\ttfamily \#include $<$Qt\+Algorithms$>$}\\*
{\ttfamily \#include $<$Q\+Var\+Length\+Array$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSearchPoint}{Search\+Point}
\item 
class \hyperlink{classTinyTextEntity}{Tiny\+Text\+Entity}
\item 
struct \hyperlink{structWordWithCharacters}{Word\+With\+Characters}
\item 
class \hyperlink{classRegionText}{Region\+Text}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classQList}{Q\+List}$<$ \hyperlink{structWordWithCharacters}{Word\+With\+Characters} $>$ \hyperlink{textpage_8cpp_ad911313b0eb678ed7fadf84147e4d1d3}{Words\+With\+Characters}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classQList}{Q\+List}$<$ \hyperlink{structQPair}{Q\+Pair}\\*
$<$ \hyperlink{textpage_8cpp_ad911313b0eb678ed7fadf84147e4d1d3}{Words\+With\+Characters}, Q\+Rect $>$ $>$ \hyperlink{textpage_8cpp_a69c9a8e3d3ed1e7180350337c5c725e2}{make\+And\+Sort\+Lines} (const \hyperlink{textpage_8cpp_ad911313b0eb678ed7fadf84147e4d1d3}{Words\+With\+Characters} \&words\+Tmp, int page\+Width, int page\+Height)
\item 
\hyperlink{textpage_8cpp_ad911313b0eb678ed7fadf84147e4d1d3}{Words\+With\+Characters} \hyperlink{textpage_8cpp_a209dadd7a945144fc847eb9bfc0a0271}{add\+Necessary\+Space} (\hyperlink{namespaceOkular_a870e45698d8c99f4400310d019c77861}{Region\+Text\+List} tree, int page\+Width, int page\+Height)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\hypertarget{textpage_8cpp_ad911313b0eb678ed7fadf84147e4d1d3}{\index{textpage.\+cpp@{textpage.\+cpp}!Words\+With\+Characters@{Words\+With\+Characters}}
\index{Words\+With\+Characters@{Words\+With\+Characters}!textpage.\+cpp@{textpage.\+cpp}}
\subsubsection[{Words\+With\+Characters}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Q\+List}$<${\bf Word\+With\+Characters}$>$ {\bf Words\+With\+Characters}}}\label{textpage_8cpp_ad911313b0eb678ed7fadf84147e4d1d3}


Definition at line 278 of file textpage.\+cpp.



\subsection{Function Documentation}
\hypertarget{textpage_8cpp_a209dadd7a945144fc847eb9bfc0a0271}{\index{textpage.\+cpp@{textpage.\+cpp}!add\+Necessary\+Space@{add\+Necessary\+Space}}
\index{add\+Necessary\+Space@{add\+Necessary\+Space}!textpage.\+cpp@{textpage.\+cpp}}
\subsubsection[{add\+Necessary\+Space}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Words\+With\+Characters} add\+Necessary\+Space (
\begin{DoxyParamCaption}
\item[{{\bf Region\+Text\+List}}]{tree, }
\item[{int}]{page\+Width, }
\item[{int}]{page\+Height}
\end{DoxyParamCaption}
)}}\label{textpage_8cpp_a209dadd7a945144fc847eb9bfc0a0271}
Add spaces in between words in a line. It reuses the pointers passed in tree and might add new ones. You will need to take care of deleting them if needed 
\begin{DoxyEnumerate}
\item Call make\+And\+Sort\+Lines before adding spaces in between words in a line
\item Now add spaces between every two words in a line
\item Finally, extract all the space separated texts from each region and return it
\end{DoxyEnumerate}

Definition at line 1805 of file textpage.\+cpp.


\begin{DoxyCode}
1806 \{
1813     \textcolor{comment}{// Only change the texts under RegionTexts, not the area}
1814     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0 ; j < tree.length() ; j++)
1815     \{
1816         \hyperlink{classRegionText}{RegionText} &tmpRegion = tree[j];
1817 
1818         \textcolor{comment}{// Step 01}
1819         \hyperlink{classQList}{QList< QPair<WordsWithCharacters, QRect>} > sortedLines = 
      \hyperlink{textpage_8cpp_a69c9a8e3d3ed1e7180350337c5c725e2}{makeAndSortLines}(tmpRegion.\hyperlink{classRegionText_a57a630a26401ff61192e66eebbd163f0}{text}(), pageWidth, pageHeight);
1820 
1821         \textcolor{comment}{// Step 02}
1822         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0 ; i < sortedLines.length() ; i++)
1823         \{
1824             \hyperlink{classQList}{WordsWithCharacters} &list = sortedLines[i].first;
1825             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k = 0 ; k < list.length() ; k++ )
1826             \{
1827                 \textcolor{keyword}{const} QRect area1 = list.at(k).area().roundedGeometry(pageWidth,pageHeight);
1828                 \textcolor{keywordflow}{if}( k+1 >= list.length() ) \textcolor{keywordflow}{break};
1829 
1830                 \textcolor{keyword}{const} QRect area2 = list.at(k+1).area().roundedGeometry(pageWidth,pageHeight);
1831                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} space = area2.left() - area1.right();
1832 
1833                 \textcolor{keywordflow}{if}(space != 0)
1834                 \{
1835                     \textcolor{comment}{// Make a TinyTextEntity of string space and push it between it and it+1}
1836                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} left = area1.right();
1837                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} right = area2.left();
1838                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} top = area2.top() < area1.top() ? area2.top() : area1.top();
1839                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} bottom = area2.bottom() > area1.bottom() ? area2.bottom() : area1.bottom();
1840 
1841                     \textcolor{keyword}{const} QString spaceStr(\textcolor{stringliteral}{" "});
1842                     \textcolor{keyword}{const} QRect rect(QPoint(left,top),QPoint(right,bottom));
1843                     \textcolor{keyword}{const} \hyperlink{classOkular_1_1NormalizedRect}{NormalizedRect} entRect(rect,pageWidth,pageHeight);
1844                     \hyperlink{classTinyTextEntity}{TinyTextEntity} *ent1 = \textcolor{keyword}{new} \hyperlink{classTinyTextEntity}{TinyTextEntity}(spaceStr, entRect
      );
1845                     \hyperlink{classTinyTextEntity}{TinyTextEntity} *ent2 = \textcolor{keyword}{new} \hyperlink{classTinyTextEntity}{TinyTextEntity}(spaceStr, entRect
      );
1846                     \hyperlink{structWordWithCharacters}{WordWithCharacters} word(ent1, 
      \hyperlink{classQList}{QList<TinyTextEntity*>}() << ent2);
1847 
1848                     list.insert(k+1, word);
1849 
1850                     \textcolor{comment}{// Skip the space}
1851                     k++;
1852                 \}
1853             \}
1854         \}
1855 
1856         \hyperlink{classQList}{WordsWithCharacters} tmpList;
1857         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0 ; i < sortedLines.length() ; i++)
1858         \{
1859             tmpList += sortedLines.at(i).first;
1860         \}
1861         tmpRegion.\hyperlink{classRegionText_ae8c5a639fec0e060eacb4247cb726da9}{setText}(tmpList);
1862     \}
1863 
1864     \textcolor{comment}{// Step 03}
1865     \hyperlink{classQList}{WordsWithCharacters} tmp;
1866     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0 ; i < tree.length() ; i++)
1867     \{
1868         tmp += tree.at(i).text();
1869     \}
1870     \textcolor{keywordflow}{return} tmp;
1871 \}
\end{DoxyCode}
\hypertarget{textpage_8cpp_a69c9a8e3d3ed1e7180350337c5c725e2}{\index{textpage.\+cpp@{textpage.\+cpp}!make\+And\+Sort\+Lines@{make\+And\+Sort\+Lines}}
\index{make\+And\+Sort\+Lines@{make\+And\+Sort\+Lines}!textpage.\+cpp@{textpage.\+cpp}}
\subsubsection[{make\+And\+Sort\+Lines}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Q\+List}$<$ {\bf Q\+Pair}$<${\bf Words\+With\+Characters}, Q\+Rect$>$ $>$ make\+And\+Sort\+Lines (
\begin{DoxyParamCaption}
\item[{const {\bf Words\+With\+Characters} \&}]{words\+Tmp, }
\item[{int}]{page\+Width, }
\item[{int}]{page\+Height}
\end{DoxyParamCaption}
)}}\label{textpage_8cpp_a69c9a8e3d3ed1e7180350337c5c725e2}
Create Lines from the words and sort them We cannot assume that the generator will give us texts in the right order. We can only assume that we will get texts in the page and their bounding rectangle. The texts can be character, word, half-\/word anything. So, we need to\+:


\begin{DoxyEnumerate}
\item Sort rectangles/boxes containing texts by y0(top)
\item Create textline where there is y overlap between \hyperlink{classTinyTextEntity}{Tiny\+Text\+Entity} 's
\item Within each line sort the \hyperlink{classTinyTextEntity}{Tiny\+Text\+Entity} 's by x0(left)
\end{DoxyEnumerate}

Definition at line 1274 of file textpage.\+cpp.


\begin{DoxyCode}
1275 \{
1287     \hyperlink{classQList}{QList< QPair<WordsWithCharacters, QRect>} > lines;
1288 
1289     \textcolor{comment}{/*}
1290 \textcolor{comment}{     Make a new copy of the TextList in the words, so that the wordsTmp and lines do}
1291 \textcolor{comment}{     not contain same pointers for all the TinyTextEntity.}
1292 \textcolor{comment}{     */}
1293     \hyperlink{classQList}{QList<WordWithCharacters>} words = wordsTmp;
1294 
1295     \textcolor{comment}{// Step 1}
1296     qSort(words.begin(),words.end(),compareTinyTextEntityY);
1297 
1298     \textcolor{comment}{// Step 2}
1299     \hyperlink{classQList}{QList<WordWithCharacters>::Iterator} it = words.begin(), itEnd = 
      words.end();
1300 
1301     \textcolor{comment}{//for every non-space texts(characters/words) in the textList}
1302     \textcolor{keywordflow}{for}( ; it != itEnd ; it++)
1303     \{
1304         \textcolor{keyword}{const} QRect elementArea = (*it).area().roundedGeometry(pageWidth,pageHeight);
1305         \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
1306 
1307         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} i = 0 ; i < lines.length() ; i++)
1308         \{
1309             \textcolor{comment}{/* the line area which will be expanded}
1310 \textcolor{comment}{               line\_rects is only necessary to preserve the topmin and bottommax of all}
1311 \textcolor{comment}{               the texts in the line, left and right is not necessary at all}
1312 \textcolor{comment}{            */}
1313             QRect &lineArea = lines[i].second;
1314             \textcolor{keyword}{const} \textcolor{keywordtype}{int} text\_y1 = elementArea.top() ,
1315                       text\_y2 = elementArea.top() + elementArea.height() ,
1316                       text\_x1 = elementArea.left(),
1317                       text\_x2 = elementArea.left() + elementArea.width();
1318             \textcolor{keyword}{const} \textcolor{keywordtype}{int} line\_y1 = lineArea.top() ,
1319                       line\_y2 = lineArea.top() + lineArea.height(),
1320                       line\_x1 = lineArea.left(),
1321                       line\_x2 = lineArea.left() + lineArea.width();
1322 
1323             \textcolor{comment}{/*}
1324 \textcolor{comment}{               if the new text and the line has y overlapping parts of more than 70%,}
1325 \textcolor{comment}{               the text will be added to this line}
1326 \textcolor{comment}{             */}
1327             \textcolor{keywordflow}{if}(doesConsumeY(elementArea,lineArea,70))
1328             \{
1329                 \hyperlink{classQList}{WordsWithCharacters} &line = lines[i].first;
1330                 line.append(*it);
1331 
1332                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} newLeft = line\_x1 < text\_x1 ? line\_x1 : text\_x1;
1333                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} newRight = line\_x2 > text\_x2 ? line\_x2 : text\_x2;
1334                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} newTop = line\_y1 < text\_y1 ? line\_y1 : text\_y1;
1335                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} newBottom = text\_y2 > line\_y2 ? text\_y2 : line\_y2;
1336 
1337                 lineArea = QRect( newLeft,newTop, newRight - newLeft, newBottom - newTop );
1338                 found = \textcolor{keyword}{true};
1339             \}
1340 
1341             \textcolor{keywordflow}{if}(found) \textcolor{keywordflow}{break};
1342         \}
1343 
1344         \textcolor{comment}{/* when we have found a new line create a new TextList containing}
1345 \textcolor{comment}{           only one element and append it to the lines}
1346 \textcolor{comment}{         */}
1347         \textcolor{keywordflow}{if}(!found)
1348         \{
1349             \hyperlink{classQList}{WordsWithCharacters} tmp;
1350             tmp.append((*it));
1351             lines.append(\hyperlink{structQPair}{QPair<WordsWithCharacters, QRect>}(tmp, 
      elementArea));
1352         \}
1353     \}
1354 
1355     \textcolor{comment}{// Step 3}
1356     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0 ; i < lines.length() ; i++)
1357     \{
1358         \hyperlink{classQList}{WordsWithCharacters} &list = lines[i].first;
1359         qSort(list.begin(), list.end(), compareTinyTextEntityX);
1360     \}
1361     
1362     \textcolor{keywordflow}{return} lines;
1363 \}
\end{DoxyCode}
