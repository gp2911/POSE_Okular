\hypertarget{classTeXFont__PK}{\section{Te\+X\+Font\+\_\+\+P\+K Class Reference}
\label{classTeXFont__PK}\index{Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}}
}


{\ttfamily \#include $<$Te\+X\+Font\+\_\+\+P\+K.\+h$>$}

Inheritance diagram for Te\+X\+Font\+\_\+\+P\+K\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classTeXFont__PK}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTeXFont__PK_a9587b31c4e2463725e0e5fbffca3b190}{Te\+X\+Font\+\_\+\+P\+K} (\hyperlink{classTeXFontDefinition}{Te\+X\+Font\+Definition} $\ast$\hyperlink{classTeXFont_a72d8eb1f0377749cf4a45dfabf1c3dd5}{parent})
\item 
\hyperlink{classTeXFont__PK_aebece9fccf3f024c72879373767a2fb4}{$\sim$\+Te\+X\+Font\+\_\+\+P\+K} ()
\item 
\hyperlink{classglyph}{glyph} $\ast$ \hyperlink{classTeXFont__PK_a0c2859ee4b390f91e8fa73e8a77e89e0}{get\+Glyph} (quint16 character, bool generate\+Character\+Pixmap=false, const Q\+Color \&color=Qt\+::black)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 11 of file Te\+X\+Font\+\_\+\+P\+K.\+h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classTeXFont__PK_a9587b31c4e2463725e0e5fbffca3b190}{\index{Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}!Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}}
\index{Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}!Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}}
\subsubsection[{Te\+X\+Font\+\_\+\+P\+K}]{\setlength{\rightskip}{0pt plus 5cm}Te\+X\+Font\+\_\+\+P\+K\+::\+Te\+X\+Font\+\_\+\+P\+K (
\begin{DoxyParamCaption}
\item[{{\bf Te\+X\+Font\+Definition} $\ast$}]{parent}
\end{DoxyParamCaption}
)}}\label{classTeXFont__PK_a9587b31c4e2463725e0e5fbffca3b190}


Definition at line 79 of file Te\+X\+Font\+\_\+\+P\+K.\+cpp.


\begin{DoxyCode}
80   : \hyperlink{classTeXFont_ac61cef23719a7d5e79b1c7fa09935b35}{TeXFont}(parent)
81 \{
82 \textcolor{preprocessor}{#ifdef DEBUG\_PK}
83   kDebug(kvs::dvi) << \textcolor{stringliteral}{"TeXFont\_PK::TeXFont\_PK( parent="} << parent << \textcolor{stringliteral}{")"};
84 \textcolor{preprocessor}{#endif}
85 
86   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<\hyperlink{classTeXFontDefinition_a542c448736e5c591257ac3889f047d66}{TeXFontDefinition::max\_num\_of\_chars\_in\_font}
      ; i++)
87     characterBitmaps[i] = 0;
88   file = fopen(QFile::encodeName(parent->\hyperlink{classTeXFontDefinition_a28d5b98d97711686c6bc0e8df3bc9cc6}{filename}), \textcolor{stringliteral}{"r"});
89   \textcolor{keywordflow}{if} (file == 0)
90     kError(kvs::dvi) << i18n(\textcolor{stringliteral}{"Cannot open font file %1."}, parent->\hyperlink{classTeXFontDefinition_a28d5b98d97711686c6bc0e8df3bc9cc6}{filename}) << endl;
91 \textcolor{preprocessor}{#ifdef DEBUG\_PK}
92   \textcolor{keywordflow}{else}
93     kDebug(kvs::dvi) << \textcolor{stringliteral}{"TeXFont\_PK::TeXFont\_PK(): file opened successfully"};
94 \textcolor{preprocessor}{#endif}
95 
96   read\_PK\_index();
97 
98 \textcolor{preprocessor}{#ifdef DEBUG\_PK}
99   kDebug(kvs::dvi) << \textcolor{stringliteral}{"TeXFont\_PK::TeXFont\_PK() ended"};
100 \textcolor{preprocessor}{#endif}
101 \}
\end{DoxyCode}
\hypertarget{classTeXFont__PK_aebece9fccf3f024c72879373767a2fb4}{\index{Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}!````~Te\+X\+Font\+\_\+\+P\+K@{$\sim$\+Te\+X\+Font\+\_\+\+P\+K}}
\index{````~Te\+X\+Font\+\_\+\+P\+K@{$\sim$\+Te\+X\+Font\+\_\+\+P\+K}!Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}}
\subsubsection[{$\sim$\+Te\+X\+Font\+\_\+\+P\+K}]{\setlength{\rightskip}{0pt plus 5cm}Te\+X\+Font\+\_\+\+P\+K\+::$\sim$\+Te\+X\+Font\+\_\+\+P\+K (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classTeXFont__PK_aebece9fccf3f024c72879373767a2fb4}


Definition at line 104 of file Te\+X\+Font\+\_\+\+P\+K.\+cpp.


\begin{DoxyCode}
105 \{
106   \textcolor{comment}{//@@@ Release bitmaps}
107   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<\hyperlink{classTeXFontDefinition_a542c448736e5c591257ac3889f047d66}{TeXFontDefinition::max\_num\_of\_chars\_in\_font}
      ; i++) \{
108     \textcolor{keyword}{delete} characterBitmaps[i];
109     characterBitmaps[i] = 0;
110   \}
111 
112   \textcolor{keywordflow}{if} (file != 0) \{
113     fclose(file);
114     file = 0;
115   \}
116 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classTeXFont__PK_a0c2859ee4b390f91e8fa73e8a77e89e0}{\index{Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}!get\+Glyph@{get\+Glyph}}
\index{get\+Glyph@{get\+Glyph}!Te\+X\+Font\+\_\+\+P\+K@{Te\+X\+Font\+\_\+\+P\+K}}
\subsubsection[{get\+Glyph}]{\setlength{\rightskip}{0pt plus 5cm}{\bf glyph} $\ast$ Te\+X\+Font\+\_\+\+P\+K\+::get\+Glyph (
\begin{DoxyParamCaption}
\item[{quint16}]{character, }
\item[{bool}]{generate\+Character\+Pixmap = {\ttfamily false}, }
\item[{const Q\+Color \&}]{color = {\ttfamily Qt\+:\+:black}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}}\label{classTeXFont__PK_a0c2859ee4b390f91e8fa73e8a77e89e0}


Implements \hyperlink{classTeXFont_a5c4953623f686aac4ec09981cf2680cf}{Te\+X\+Font}.



Definition at line 119 of file Te\+X\+Font\+\_\+\+P\+K.\+cpp.


\begin{DoxyCode}
120 \{
121 \textcolor{preprocessor}{#ifdef DEBUG\_PK}
122   kDebug(kvs::dvi) << \textcolor{stringliteral}{"TeXFont\_PK::getGlyph( ch="} << ch << \textcolor{stringliteral}{", generateCharacterPixmap="} << 
      generateCharacterPixmap << \textcolor{stringliteral}{" )"};
123 \textcolor{preprocessor}{#endif}
124 
125   \textcolor{comment}{// Paranoia checks}
126   \textcolor{keywordflow}{if} (ch >= \hyperlink{classTeXFontDefinition_a542c448736e5c591257ac3889f047d66}{TeXFontDefinition::max\_num\_of\_chars\_in\_font}) \{
127     kError(kvs::dvi) << \textcolor{stringliteral}{"TeXFont\_PK::getGlyph(): Argument is too big."} << endl;
128     \textcolor{keywordflow}{return} \hyperlink{classTeXFont_a4ec465c9b189f0845a25ad5c99903e5f}{glyphtable};
129   \}
130 
131   \textcolor{comment}{// This is the address of the glyph that will be returned.}
132   \textcolor{keyword}{class }\hyperlink{classglyph}{glyph} *g = \hyperlink{classTeXFont_a4ec465c9b189f0845a25ad5c99903e5f}{glyphtable}+ch;
133 
134   \textcolor{comment}{// Check if the glyph is loaded. If not, load it now.}
135   \textcolor{keywordflow}{if} (characterBitmaps[ch] == 0) \{
136     \textcolor{comment}{// If the character is not defined in the PK file, mark the}
137     \textcolor{comment}{// character as missing, and print an error message}
138     \textcolor{keywordflow}{if} (g->\hyperlink{classglyph_a11666f9bdd93248a6c58b69113cbd7b0}{addr} == 0) \{
139       kError(kvs::dvi) << i18n(\textcolor{stringliteral}{"TexFont\_PK::operator[]: Character %1 not defined in font %2"}, ch, 
      \hyperlink{classTeXFont_a72d8eb1f0377749cf4a45dfabf1c3dd5}{parent}->\hyperlink{classTeXFontDefinition_a28d5b98d97711686c6bc0e8df3bc9cc6}{filename}) << endl;
140       g->\hyperlink{classglyph_a11666f9bdd93248a6c58b69113cbd7b0}{addr} = -1;
141       \textcolor{keywordflow}{return} g;
142     \}
143 
144     \textcolor{comment}{// If the character has already been marked as missing, just}
145     \textcolor{comment}{// return a pointer to the glyph (which will then be empty)}
146     \textcolor{keywordflow}{if} (g->\hyperlink{classglyph_a11666f9bdd93248a6c58b69113cbd7b0}{addr} == -1)
147       \textcolor{keywordflow}{return} g;
148 
149     \textcolor{comment}{// Otherwise, try to load the character}
150     fseek(file, g->\hyperlink{classglyph_a11666f9bdd93248a6c58b69113cbd7b0}{addr}, 0);
151     read\_PK\_char(ch);
152     \textcolor{comment}{// Check if the character could be loaded. If not, mark the}
153     \textcolor{comment}{// character as 'missing', and return a pointer.}
154     \textcolor{keywordflow}{if} (characterBitmaps[ch]->bits == 0) \{
155       g->\hyperlink{classglyph_a11666f9bdd93248a6c58b69113cbd7b0}{addr} = -1;
156       \textcolor{keywordflow}{return} g;
157     \}
158   \}
159 
160   \textcolor{comment}{// At this point, g points to a properly loaded character. Generate}
161   \textcolor{comment}{// a smoothly scaled QPixmap if the user asks for it.}
162   \textcolor{keywordflow}{if} ((generateCharacterPixmap == \textcolor{keyword}{true}) &&
163       ((g->\hyperlink{classglyph_aeefa28a926bdd7a24595dbdc7cdf504c}{shrunkenCharacter}.isNull()) || (\hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color} != g->
      \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color})) &&
164       (characterBitmaps[ch]->w != 0)) \{
165     g->\hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color} = \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color};
166     \textcolor{keywordtype}{double} shrinkFactor = 1200 / \hyperlink{classTeXFont_a72d8eb1f0377749cf4a45dfabf1c3dd5}{parent}->\hyperlink{classTeXFontDefinition_a08e27df7d9764c43308c5637906658c5}{displayResolution\_in\_dpi};
167 
168     \textcolor{comment}{// All is fine? Then we rescale the bitmap in order to produce the}
169     \textcolor{comment}{// required pixmap.  Rescaling a character, however, is an art}
170     \textcolor{comment}{// that requires some explanation...}
171     \textcolor{comment}{//}
172     \textcolor{comment}{// If we would just divide the size of the character and the}
173     \textcolor{comment}{// coordinates by the shrink factor, then the result would look}
174     \textcolor{comment}{// quite ugly: due to the ineviatable rounding errors in the}
175     \textcolor{comment}{// integer arithmetic, the characters would be displaced by up to}
176     \textcolor{comment}{// a pixel. That doesn't sound much, but on low-resolution}
177     \textcolor{comment}{// devices, such as a notebook screen, the effect would be a}
178     \textcolor{comment}{// "dancing line" of characters, which looks really bad.}
179 
180     \textcolor{comment}{// Calculate the coordinates of the hot point in the shrunken}
181     \textcolor{comment}{// bitmap. For simplicity, let us consider the x-coordinate}
182     \textcolor{comment}{// first. In principle, the hot point should have an x-coordinate}
183     \textcolor{comment}{// of (g->x/shrinkFactor). That, however, will generally NOT be an}
184     \textcolor{comment}{// integral number. The cure is to translate the source image}
185     \textcolor{comment}{// somewhat, so that the x-coordinate of the hot point falls onto}
186     \textcolor{comment}{// the round-up of this number, i.e.}
187     g->\hyperlink{classglyph_a07a7aa840a9a34588a5cc02508ac5e6d}{x2} = (int)ceil(g->\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}/shrinkFactor);
188 
189     \textcolor{comment}{// Translating and scaling then means that the pixel in the scaled}
190     \textcolor{comment}{// image which covers the range [x,x+1) corresponds to the range}
191     \textcolor{comment}{// [x*shrinkFactor+srcXTrans, (x+1)*shrinkFactor+srcXTrans), where}
192     \textcolor{comment}{// srcXTrans is the following NEGATIVE number}
193     \textcolor{keywordtype}{double} srcXTrans = shrinkFactor * (g->\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}/shrinkFactor - ceil(g->\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}/shrinkFactor));
194 
195     \textcolor{comment}{// How big will the shrunken bitmap then become? If shrunk\_width}
196     \textcolor{comment}{// denotes that width of the scaled image, and}
197     \textcolor{comment}{// characterBitmaps[ch]->w the width of the orininal image, we}
198     \textcolor{comment}{// need to make sure that the following inequality holds:}
199     \textcolor{comment}{//}
200     \textcolor{comment}{// shrunk\_width*shrinkFactor+srcXTrans >= characterBitmaps[ch]->w}
201     \textcolor{comment}{//}
202     \textcolor{comment}{// in other words,}
203     \textcolor{keywordtype}{int} shrunk\_width  = (int)ceil( (characterBitmaps[ch]->w - srcXTrans)/shrinkFactor );
204 
205     \textcolor{comment}{// Now do the same for the y-coordinate}
206     g->\hyperlink{classglyph_afa1607f13eb1db99a5a3b1c92d47db7f}{y2} = (int)ceil(g->\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}/shrinkFactor);
207     \textcolor{keywordtype}{double} srcYTrans = shrinkFactor * (g->\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}/shrinkFactor - ceil(g->\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}/shrinkFactor ));
208     \textcolor{keywordtype}{int} shrunk\_height = (int)ceil( (characterBitmaps[ch]->h - srcYTrans)/shrinkFactor );
209 
210     \textcolor{comment}{// Turn the image into 8 bit}
211     QByteArray translated(characterBitmaps[ch]->w * characterBitmaps[ch]->h, \textcolor{charliteral}{'\(\backslash\)0'});
212     quint8 *data = (quint8 *)translated.data();
213     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}=0; \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}<characterBitmaps[ch]->\hyperlink{structbitmap_a955acbe13f247a259cbe10ced3a212fd}{w}; \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}++)
214       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}=0; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}<characterBitmaps[ch]->\hyperlink{structbitmap_a34f28c8404007de8ede4b9a6b5e425dd}{h}; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}++) \{
215         quint8 bit = *(characterBitmaps[ch]->\hyperlink{structbitmap_a5d74448ece4936321ffd2bdc4fabe445}{bits} + characterBitmaps[ch]->
      \hyperlink{structbitmap_ae248def3f3413e79d52541195017a32c}{bytes\_wide}*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + (\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x} >> 3));
216         bit = bit >> (\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x} & 7);
217         bit = bit & 1;
218         data[characterBitmaps[ch]->\hyperlink{structbitmap_a955acbe13f247a259cbe10ced3a212fd}{w}*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}] = bit;
219       \}
220 
221     \textcolor{comment}{// Now shrink the image. We shrink the X-direction first}
222     QByteArray xshrunk(shrunk\_width*characterBitmaps[ch]->h, \textcolor{charliteral}{'\(\backslash\)0'});
223     quint8 *xdata = (quint8 *)xshrunk.data();
224 
225     \textcolor{comment}{// Do the shrinking. The pixel (x,y) that we want to calculate}
226     \textcolor{comment}{// corresponds to the line segment from}
227     \textcolor{comment}{//}
228     \textcolor{comment}{// [shrinkFactor*x+srcXTrans, shrinkFactor*(x+1)+srcXTrans)}
229     \textcolor{comment}{//}
230     \textcolor{comment}{// The trouble is, these numbers are in general no integers.}
231 
232     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}=0; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}<characterBitmaps[ch]->\hyperlink{structbitmap_a34f28c8404007de8ede4b9a6b5e425dd}{h}; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}++)
233       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}=0; \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}<shrunk\_width; \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}++) \{
234         quint32 value = 0;
235         \textcolor{keywordtype}{double} destStartX = shrinkFactor*\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}+srcXTrans;
236         \textcolor{keywordtype}{double} destEndX   = shrinkFactor*(\hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}+1)+srcXTrans;
237         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} srcX=(\textcolor{keywordtype}{int})ceil(destStartX); srcX<floor(destEndX); srcX++)
238           \textcolor{keywordflow}{if} ((srcX >= 0) && (srcX < characterBitmaps[ch]->\hyperlink{structbitmap_a955acbe13f247a259cbe10ced3a212fd}{w}))
239             value += data[characterBitmaps[ch]->\hyperlink{structbitmap_a955acbe13f247a259cbe10ced3a212fd}{w}*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + srcX] * 255;
240 
241         \textcolor{keywordflow}{if} (destStartX >= 0.0)
242           value += (quint32) (255.0*(ceil(destStartX)-destStartX) * data[characterBitmaps[ch]->w*
      \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + (\textcolor{keywordtype}{int})floor(destStartX)]);
243         \textcolor{keywordflow}{if} (floor(destEndX) < characterBitmaps[ch]->w)
244           value += (quint32) (255.0*(destEndX-floor(destEndX)) * data[characterBitmaps[ch]->w*
      \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + (\textcolor{keywordtype}{int})floor(destEndX)]);
245 
246         xdata[shrunk\_width*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}] = (int)(value/shrinkFactor + 0.5);
247       \}
248 
249     \textcolor{comment}{// Now shrink the Y-direction}
250     QByteArray xyshrunk(shrunk\_width*shrunk\_height, \textcolor{charliteral}{'\(\backslash\)0'});
251     quint8 *xydata = (quint8 *)xyshrunk.data();
252     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}=0; \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}<shrunk\_width; \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}++)
253       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}=0; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}<shrunk\_height; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}++) \{
254         quint32 value = 0;
255         \textcolor{keywordtype}{double} destStartY = shrinkFactor*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}+srcYTrans;
256         \textcolor{keywordtype}{double} destEndY   = shrinkFactor*(\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}+1)+srcYTrans;
257         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} srcY=(\textcolor{keywordtype}{int})ceil(destStartY); srcY<floor(destEndY); srcY++)
258           \textcolor{keywordflow}{if} ((srcY >= 0) && (srcY < characterBitmaps[ch]->h))
259             value += xdata[shrunk\_width*srcY + \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}];
260 
261         \textcolor{keywordflow}{if} (destStartY >= 0.0)
262           value += (quint32) ((ceil(destStartY)-destStartY) * xdata[shrunk\_width*(\textcolor{keywordtype}{int})floor(destStartY) + 
      \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}]);
263         \textcolor{keywordflow}{if} (floor(destEndY) < characterBitmaps[ch]->h)
264           value += (quint32) ((destEndY-floor(destEndY)) * xdata[shrunk\_width*(\textcolor{keywordtype}{int})floor(destEndY) + 
      \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}]);
265 
266         xydata[shrunk\_width*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + \hyperlink{classglyph_aa030c1619dd07d04f843c5ee9a54dde1}{x}] = (int)(value/shrinkFactor);
267       \}
268 
269     QImage im32(shrunk\_width, shrunk\_height, QImage::Format\_ARGB32);
270     \textcolor{comment}{// Do QPixmaps fully support the alpha channel? If yes, we use}
271     \textcolor{comment}{// that. Otherwise, use other routines as a fallback}
272     \textcolor{keywordflow}{if} (\hyperlink{classTeXFont_a72d8eb1f0377749cf4a45dfabf1c3dd5}{parent}->\hyperlink{classTeXFontDefinition_abc8dfc7c07e8d998150e4ab09f9f9bec}{font\_pool}->\hyperlink{classfontPool_af02ca5badcfd15a93f871606867909b7}{QPixmapSupportsAlpha}) \{
273       \textcolor{comment}{// If the alpha channel is properly supported, we set the}
274       \textcolor{comment}{// character glyph to a colored rectangle, and define the}
275       \textcolor{comment}{// character outline only using the alpha channel. That ensures}
276       \textcolor{comment}{// good quality rendering for overlapping characters.}
277       im32.fill(qRgb(\hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color}.red(), \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color}.green(), \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color}.blue()));
278       \textcolor{keywordflow}{for}(quint16 \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}=0; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}<shrunk\_height; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}++) \{
279         quint8 *destScanLine = (quint8 *)im32.scanLine(\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y});
280         \textcolor{keywordflow}{for}(quint16 col=0; col<shrunk\_width; col++)
281           destScanLine[4*col+3] = xydata[shrunk\_width*\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y} + col];
282       \}
283     \} \textcolor{keywordflow}{else} \{
284       \textcolor{comment}{// If the alpha channel is not supported... QT seems to turn the}
285       \textcolor{comment}{// alpha channel into a crude bitmap which is used to mask the}
286       \textcolor{comment}{// resulting QPixmap. In this case, we define the character}
287       \textcolor{comment}{// outline using the image data, and use the alpha channel only}
288       \textcolor{comment}{// to store "maximally opaque" or "completely transparent"}
289       \textcolor{comment}{// values. When characters are rendered, overlapping characters}
290       \textcolor{comment}{// are no longer correctly drawn, but quality is still}
291       \textcolor{comment}{// sufficient for most purposes. One notable exception is output}
292       \textcolor{comment}{// from the gftodvi program, which will be partially unreadable.}
293       quint16 rInv = 0xFF - \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color}.red();
294       quint16 gInv = 0xFF - \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color}.green();
295       quint16 bInv = 0xFF - \hyperlink{classglyph_ab4847af7a7b13322d5651fe47735c8dd}{color}.blue();
296 
297       quint8 *srcScanLine = xydata;
298       \textcolor{keywordflow}{for}(quint16 \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}=0; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}<shrunk\_height; \hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y}++) \{
299         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *destScanLine = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *)im32.scanLine(\hyperlink{classglyph_ac9b8f10a7be77024f34c723eeea34bf3}{y});
300         \textcolor{keywordflow}{for}(quint16 col=0; col<shrunk\_width; col++) \{
301           quint16 data =  *srcScanLine;
302           \textcolor{comment}{// The value stored in "data" now has the following meaning:}
303           \textcolor{comment}{// data = 0 -> white; data = 0xff -> use "color"}
304           *destScanLine = qRgba(0xFF - (rInv*data + 0x7F) / 0xFF,
305                                 0xFF - (gInv*data + 0x7F) / 0xFF,
306                                 0xFF - (bInv*data + 0x7F) / 0xFF,
307                                 (data > 0x03) ? 0xff : 0x00);
308           destScanLine++;
309           srcScanLine++;
310         \}
311       \}
312     \}
313 
314     g->\hyperlink{classglyph_aeefa28a926bdd7a24595dbdc7cdf504c}{shrunkenCharacter} = im32;
315   \}
316   \textcolor{keywordflow}{return} g;
317 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
generators/dvi/\hyperlink{TeXFont__PK_8h}{Te\+X\+Font\+\_\+\+P\+K.\+h}\item 
generators/dvi/\hyperlink{TeXFont__PK_8cpp}{Te\+X\+Font\+\_\+\+P\+K.\+cpp}\end{DoxyCompactItemize}
