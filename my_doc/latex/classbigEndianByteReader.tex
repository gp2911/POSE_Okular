\hypertarget{classbigEndianByteReader}{\section{big\+Endian\+Byte\+Reader Class Reference}
\label{classbigEndianByteReader}\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
}


{\ttfamily \#include $<$big\+Endian\+Byte\+Reader.\+h$>$}

Inheritance diagram for big\+Endian\+Byte\+Reader\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classbigEndianByteReader}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
quint8 \hyperlink{classbigEndianByteReader_ac5e3b96e3e09b30dbe57175763077c1f}{read\+U\+I\+N\+T8} ()
\item 
quint16 \hyperlink{classbigEndianByteReader_a870af9d9b5ed04507d392ad2d81c1f53}{read\+U\+I\+N\+T16} ()
\item 
quint32 \hyperlink{classbigEndianByteReader_a39c3b90a7617e40cef20796fbc680df8}{read\+U\+I\+N\+T32} ()
\item 
void \hyperlink{classbigEndianByteReader_ad7b98fdfcac31d1f30b65d2de0f2a97a}{write\+U\+I\+N\+T32} (quint32 a)
\item 
quint32 \hyperlink{classbigEndianByteReader_ace27c2b08d57237a09d84af65891d4b4}{read\+U\+I\+N\+T} (quint8 \hyperlink{synctex__parser_8c_aa23c661441688350614bd6a350d2b6ff}{size})
\item 
qint32 \hyperlink{classbigEndianByteReader_ad85cb1f2cce7f4de7abc632b5e95223b}{read\+I\+N\+T} (quint8)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
quint8 $\ast$ \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\+\_\+pointer}
\item 
quint8 $\ast$ \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\+\_\+pointer}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Byte reading routines which read big endian numbers from memory and convert them to native integers.

\begin{DoxyAuthor}{Author}
Stefan Kebekus (\href{mailto:kebekus@kde.org}{\tt kebekus@kde.\+org}) 
\end{DoxyAuthor}


Definition at line 24 of file big\+Endian\+Byte\+Reader.\+h.



\subsection{Member Function Documentation}
\hypertarget{classbigEndianByteReader_ad85cb1f2cce7f4de7abc632b5e95223b}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!read\+I\+N\+T@{read\+I\+N\+T}}
\index{read\+I\+N\+T@{read\+I\+N\+T}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{read\+I\+N\+T}]{\setlength{\rightskip}{0pt plus 5cm}qint32 big\+Endian\+Byte\+Reader\+::read\+I\+N\+T (
\begin{DoxyParamCaption}
\item[{quint8}]{length}
\end{DoxyParamCaption}
)}}\label{classbigEndianByteReader_ad85cb1f2cce7f4de7abc632b5e95223b}
Similar to the method above, only that the method reads a S\+I\+G\+N\+E\+D number 

Definition at line 96 of file big\+Endian\+Byte\+Reader.\+cpp.


\begin{DoxyCode}
97 \{
98   \textcolor{comment}{// This check saveguards us against segmentation fault. It is also}
99   \textcolor{comment}{// necessary for virtual fonts, which do not end with EOP.}
100   \textcolor{keywordflow}{if} (\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} >= \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer})
101     \textcolor{keywordflow}{return} \hyperlink{dvi_8h_a734579b908509b57151ac02b946056d1}{EOP};
102 
103   qint32 a = *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
104 
105   \textcolor{keywordflow}{if} (a & 0x80)
106     a -= 0x100;
107 
108   \textcolor{keywordflow}{while} ((--length) > 0)
109     a = (a << 8) | *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
110 
111   \textcolor{keywordflow}{return} a;
112 \}
\end{DoxyCode}
\hypertarget{classbigEndianByteReader_ace27c2b08d57237a09d84af65891d4b4}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!read\+U\+I\+N\+T@{read\+U\+I\+N\+T}}
\index{read\+U\+I\+N\+T@{read\+U\+I\+N\+T}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{read\+U\+I\+N\+T}]{\setlength{\rightskip}{0pt plus 5cm}quint32 big\+Endian\+Byte\+Reader\+::read\+U\+I\+N\+T (
\begin{DoxyParamCaption}
\item[{quint8}]{size}
\end{DoxyParamCaption}
)}}\label{classbigEndianByteReader_ace27c2b08d57237a09d84af65891d4b4}
Similar to the method above, only that the method reads a big endian number of length size, where 1 $<$= size $<$= 4. Note that the value 3 is allowed (and is actually used in D\+V\+I files)!!! 

Definition at line 81 of file big\+Endian\+Byte\+Reader.\+cpp.


\begin{DoxyCode}
82 \{
83   \textcolor{comment}{// This check saveguards us against segmentation fault. It is also}
84   \textcolor{comment}{// necessary for virtual fonts, which do not end with EOP.}
85   \textcolor{keywordflow}{if} (\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} >= \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer})
86     \textcolor{keywordflow}{return} \hyperlink{dvi_8h_a734579b908509b57151ac02b946056d1}{EOP};
87 
88   quint32 a = 0;
89   \textcolor{keywordflow}{while} (\hyperlink{synctex__parser_8c_aa23c661441688350614bd6a350d2b6ff}{size} > 0) \{
90     a = (a << 8) + *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
91     \hyperlink{synctex__parser_8c_aa23c661441688350614bd6a350d2b6ff}{size}--;
92   \}
93   \textcolor{keywordflow}{return} a;
94 \}
\end{DoxyCode}
\hypertarget{classbigEndianByteReader_a870af9d9b5ed04507d392ad2d81c1f53}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!read\+U\+I\+N\+T16@{read\+U\+I\+N\+T16}}
\index{read\+U\+I\+N\+T16@{read\+U\+I\+N\+T16}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{read\+U\+I\+N\+T16}]{\setlength{\rightskip}{0pt plus 5cm}quint16 big\+Endian\+Byte\+Reader\+::read\+U\+I\+N\+T16 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classbigEndianByteReader_a870af9d9b5ed04507d392ad2d81c1f53}
Similar to the method above, only that the method reads a big endian 2-\/byte word and increases the pointer by two. 

Definition at line 34 of file big\+Endian\+Byte\+Reader.\+cpp.


\begin{DoxyCode}
35 \{
36   \textcolor{comment}{// This check saveguards us against segmentation fault. It is also}
37   \textcolor{comment}{// necessary for virtual fonts, which do not end with EOP.}
38   \textcolor{keywordflow}{if} (\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} >= \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer})
39     \textcolor{keywordflow}{return} \hyperlink{dvi_8h_a734579b908509b57151ac02b946056d1}{EOP};
40 
41   quint16 a;
42   a = *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
43   a = (a << 8) | *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
44   \textcolor{keywordflow}{return} a;
45 \}
\end{DoxyCode}
\hypertarget{classbigEndianByteReader_a39c3b90a7617e40cef20796fbc680df8}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!read\+U\+I\+N\+T32@{read\+U\+I\+N\+T32}}
\index{read\+U\+I\+N\+T32@{read\+U\+I\+N\+T32}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{read\+U\+I\+N\+T32}]{\setlength{\rightskip}{0pt plus 5cm}quint32 big\+Endian\+Byte\+Reader\+::read\+U\+I\+N\+T32 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classbigEndianByteReader_a39c3b90a7617e40cef20796fbc680df8}
Similar to the method above, only that the method reads a big endian 4-\/byte word and increases the pointer by four. 

Definition at line 47 of file big\+Endian\+Byte\+Reader.\+cpp.


\begin{DoxyCode}
48 \{
49   \textcolor{comment}{// This check saveguards us against segmentation fault. It is also}
50   \textcolor{comment}{// necessary for virtual fonts, which do not end with EOP.}
51   \textcolor{keywordflow}{if} (\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} >= \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer})
52     \textcolor{keywordflow}{return} \hyperlink{dvi_8h_a734579b908509b57151ac02b946056d1}{EOP};
53 
54   quint32 a;
55   a = *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
56   a = (a << 8) | *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
57   a = (a << 8) | *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
58   a = (a << 8) | *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
59   \textcolor{keywordflow}{return} a;
60 \}
\end{DoxyCode}
\hypertarget{classbigEndianByteReader_ac5e3b96e3e09b30dbe57175763077c1f}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!read\+U\+I\+N\+T8@{read\+U\+I\+N\+T8}}
\index{read\+U\+I\+N\+T8@{read\+U\+I\+N\+T8}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{read\+U\+I\+N\+T8}]{\setlength{\rightskip}{0pt plus 5cm}quint8 big\+Endian\+Byte\+Reader\+::read\+U\+I\+N\+T8 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classbigEndianByteReader_ac5e3b96e3e09b30dbe57175763077c1f}
If command\+\_\+pointer $>$= end\+\_\+pointer, this method return E\+O\+P (=140) and exists. Otherwise, the method returns the unsigned byte and increases the command\+\_\+pointer by one. 

Definition at line 18 of file big\+Endian\+Byte\+Reader.\+cpp.


\begin{DoxyCode}
19 \{
20   \textcolor{comment}{// This check saveguards us against segmentation fault. It is also}
21   \textcolor{comment}{// necessary for virtual fonts, which do not end with EOP.}
22   \textcolor{keywordflow}{if} (\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} >= \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer}) \{
23 \textcolor{preprocessor}{#ifdef DEBUG\_ENDIANREADER}
24     kError(kvs::dvi) << \textcolor{stringliteral}{"bigEndianByteReader::readUINT8() tried to read past end of data chunk"} << endl;
25     kError(kvs::dvi) << \textcolor{stringliteral}{"end\_pointer     = "} << \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer} << endl;
26     kError(kvs::dvi) << \textcolor{stringliteral}{"command\_pointer = "} << \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} << endl;
27 \textcolor{preprocessor}{#endif}
28     \textcolor{keywordflow}{return} \hyperlink{dvi_8h_a734579b908509b57151ac02b946056d1}{EOP};
29   \}
30 
31   \textcolor{keywordflow}{return} *(\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}++);
32 \}
\end{DoxyCode}
\hypertarget{classbigEndianByteReader_ad7b98fdfcac31d1f30b65d2de0f2a97a}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!write\+U\+I\+N\+T32@{write\+U\+I\+N\+T32}}
\index{write\+U\+I\+N\+T32@{write\+U\+I\+N\+T32}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{write\+U\+I\+N\+T32}]{\setlength{\rightskip}{0pt plus 5cm}void big\+Endian\+Byte\+Reader\+::write\+U\+I\+N\+T32 (
\begin{DoxyParamCaption}
\item[{quint32}]{a}
\end{DoxyParamCaption}
)}}\label{classbigEndianByteReader_ad7b98fdfcac31d1f30b65d2de0f2a97a}


Definition at line 62 of file big\+Endian\+Byte\+Reader.\+cpp.


\begin{DoxyCode}
63 \{
64   \textcolor{comment}{// This check saveguards us against segmentation fault. It is also}
65   \textcolor{comment}{// necessary for virtual fonts, which do not end with EOP.}
66   \textcolor{keywordflow}{if} (\hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} >= \hyperlink{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{end\_pointer})
67     \textcolor{keywordflow}{return};
68 
69   \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}[3] = (quint8)(a & 0xFF);
70   a = a >> 8;
71   \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}[2] = (quint8)(a & 0xFF);
72   a = a >> 8;
73   \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}[1] = (quint8)(a & 0xFF);
74   a = a >> 8;
75   \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer}[0] = (quint8)(a & 0xFF);
76 
77   \hyperlink{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{command\_pointer} += 4;
78   \textcolor{keywordflow}{return};
79 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!command\+\_\+pointer@{command\+\_\+pointer}}
\index{command\+\_\+pointer@{command\+\_\+pointer}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{command\+\_\+pointer}]{\setlength{\rightskip}{0pt plus 5cm}quint8$\ast$ big\+Endian\+Byte\+Reader\+::command\+\_\+pointer}}\label{classbigEndianByteReader_aa8919f6fe116fd3230337675fd23abac}
Set this pointer to the location where the number resides which you want to read. 

Definition at line 28 of file big\+Endian\+Byte\+Reader.\+h.

\hypertarget{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}{\index{big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}!end\+\_\+pointer@{end\+\_\+pointer}}
\index{end\+\_\+pointer@{end\+\_\+pointer}!big\+Endian\+Byte\+Reader@{big\+Endian\+Byte\+Reader}}
\subsubsection[{end\+\_\+pointer}]{\setlength{\rightskip}{0pt plus 5cm}quint8$\ast$ big\+Endian\+Byte\+Reader\+::end\+\_\+pointer}}\label{classbigEndianByteReader_ace2790221530572c87c58f1f77924beb}
This pointer marks the end of the memory area where bytes can be read. It should point to the first byte which C\+A\+N\+N\+O\+T be read. The idea is to have a safety net which protects us against S\+E\+G\+F\+A\+U\+L\+Ts. This is also used in virtual fonts, where the macro does not have an E\+O\+P command at the end of the macro. 

Definition at line 35 of file big\+Endian\+Byte\+Reader.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
generators/dvi/\hyperlink{bigEndianByteReader_8h}{big\+Endian\+Byte\+Reader.\+h}\item 
generators/dvi/\hyperlink{bigEndianByteReader_8cpp}{big\+Endian\+Byte\+Reader.\+cpp}\end{DoxyCompactItemize}
